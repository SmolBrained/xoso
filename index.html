<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>WebGL Alexa Game</title>
<script src="https://d2o906d8ln7ui1.cloudfront.net/alexa.html.js"></script>
<style>
body,canvas{margin:0;padding:0;display:block;width:100vw;height:100vh;background:#000;color:#fff;font-family:Arial,sans-serif;overflow:hidden}
#debugOverlay{position:fixed;top:10px;left:10px;color:white;font-family:monospace;pointer-events:none;display:none;background:rgba(0,0,0,0.5);padding:10px;border-radius:5px}
</style>
</head>
<body class="overflow-hidden">
<canvas id="gameCanvas"></canvas>
<div id="debugOverlay"></div>
<script>
const canvas=document.getElementById("gameCanvas"),debugOverlay=document.getElementById("debugOverlay");
let gl=canvas.getContext("webgl2",{antialias:false});
if (!gl) {
    gl = canvas.getContext("experimental-webgl");
}
if (!gl) alert("Your browser does not support WebGL");

let alexa;
const playerPosition=[2.28,0.72,2.56],playerVelocity=[0,0,0],playerRotation=[0.00,0.00,0.00],lastDrawTime=performance.now(),fps=0,developerMode=false,gravityEnabled=true,collisionsEnabled=true,models={},buffers={},showHitboxes=false,wireProgram=null,hitboxBuffer=null,hitboxIndexBuffer=null,playerCollisionBuffer=null;
const GRAVITY=-9.81,JUMP_FORCE=7,PLAYER_RADIUS=0.5,PLAYER_CAPSULE_HEIGHT=1.0,MAX_FALL_SPEED=-20,GROUND_EPSILON=0.3;
const TWO_PI = Math.PI * 2;
let moveInput = { forward: 0, strafe: 0, vertical: 0 };
let lookInput = { yaw: 0, pitch: 0 };
const LOOK_SENSITIVITY = 0.05;
const MOVE_SPEED = 5;
const FLY_SPEED = 5;

const world=[
{
name:"dummy",
texture: "./assets/KLw2c2n.png",
position: [0,1,0],
rotation: [0,0,0],
scale: [0.01,0.01,0.01],
hasCollision: true,
hasGravity: true,
},
{
name:"cube",
texture: "./assets/Tug6B9V.jpeg",
position:[0,0,0],
rotation:[Math.PI/2,0,0],
scale:[1,1,1],
hasCollision:true,
hasGravity:true,
},
{
name:"dummy",
texture: "./assets/KLw2c2n.png",
position: [10,1,0],
rotation: [0,0,0],
scale: [0.01,0.01,0.01],
hasCollision: true,
hasGravity: true,
},
{
name:"cube",
texture: "./assets/Tug6B9V.jpeg",
position:[10,0,0],
rotation:[Math.PI/2,0,0],
scale:[1,1,1],
hasCollision:true,
hasGravity:true,
},
{
name:"dummy",
texture: "./assets/KLw2c2n.png",
position: [-10,1,0],
rotation: [0,0,0],
scale: [0.01,0.01,0.01],
hasCollision: true,
hasGravity: true,
},
{
name:"cube",
texture: "./assets/Tug6B9V.jpeg",
position:[-10,0,0],
rotation:[Math.PI/2,0,0],
scale:[1,1,1],
hasCollision:true,
hasGravity:true,
},
{
name:"cube",
texture:"./assets/BNWOA07.jpeg",
position:[0,-2.0,0],
rotation:[0,0,0],
scale:[20,1,20],
hasCollision:true,
hasGravity:false,
},
];

const vertexShaderSource=`#version 300 es
layout (location = 0) in vec3 position;
layout (location = 1) in vec2 texcoord;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 objectMatrix;
out vec2 vTexcoord;
void main(){
    vTexcoord = texcoord;
    vec4 worldPosition = objectMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * worldPosition;
}`;

const fragmentShaderSource=`#version 300 es
precision highp float;
in vec2 vTexcoord;
uniform sampler2D uTexture;
out vec4 FragColor;
void main() {
    FragColor = texture(uTexture, vTexcoord);
}`;

const wireVertexShaderSource=`#version 300 es
layout (location = 0) in vec3 position;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
void main(){
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

const wireFragmentShaderSource=`#version 300 es
precision mediump float;
uniform vec4 color;
out vec4 FragColor;
void main(){
    FragColor = color;
}`;

function computeBoundingBox(vs){
let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
for(let i=0;i<vs.length;i+=3){
let x=vs[i],y=vs[i+1],z=vs[i+2];
if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z; if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;
}
return {minX,minY,minZ,width:maxX-minX,height:maxY-minY,depth:maxZ-minZ};
}
function transformPoint(m,p){ return [m[0]*p[0]+m[4]*p[1]+m[8]*p[2]+m[12],m[1]*p[0]+m[5]*p[1]+m[9]*p[2]+m[13],m[2]*p[0]+m[6]*p[1]+m[10]*p[2]+m[14]]; }
function closestPointOnTriangle(p,a,b,c){
let ab=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],ac=[c[0]-a[0],c[1]-a[1],c[2]-a[2]],ap=[p[0]-a[0],p[1]-a[1],p[2]-a[2]],d1=dot(ap,ab),d2=dot(ap,ac); if(d1<=0&&d2<=0)return a;
let bp=[p[0]-b[0],p[1]-b[1],p[2]-b[2]],d3=dot(bp,ab),d4=dot(bp,ac); if(d3>=0&&d4<=d3)return b;
let vc=d1*d4-d3*d2; if(vc<=0&&d1>=0&&d3<=0){let v=d1/(d1-d3);return [a[0]+v*ab[0],a[1]+v*ab[1],a[2]+v*ab[2]];}
let cp=[p[0]-c[0],p[1]-c[1],p[2]-c[2]],d5=dot(cp,ab),d6=dot(cp,ac); if(d6>=0&&d5<=d6)return c;
let vb=d5*d2-d1*d6; if(vb<=0&&d2>=0&&d6<=0){let w=d2/(d2-d6);return [a[0]+w*ac[0],a[1]+w*ac[1],a[2]+w*ac[2]];}
let va=d3*d6-d5*d4; if(va<=0&&(d4-d3)>=0&&(d5-d6)>=0){let w=(d4-d3)/((d4-d3)+(d5-d6));let bc=[c[0]-b[0],c[1]-b[1],c[2]-b[2]];return [b[0]+w*bc[0],b[1]+w*bc[1],b[2]+w*bc[2]];}
let denom=1/(va+vb+vc),v=vb*denom,w=vc*denom; return [a[0]+ab[0]*v+ac[0]*w,a[1]+ab[1]*v+ac[1]*w,a[2]+ab[2]*v+ac[2]*w];
}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}
function normalize(v){let l=Math.hypot(v[0],v[1],v[2]);return l===0?[0,0,0]:[v[0]/l,v[1]/l,v[2]/l];}

function createFlatShadedData(vertices, uvCoords, indices) {
    let finalVertices = [], finalUvCoords = [];
    for (let i = 0; i < indices.length; i += 3) {
        let idx1 = indices[i], idx2 = indices[i + 1], idx3 = indices[i + 2];
        let v1 = [vertices[idx1 * 3], vertices[idx1 * 3 + 1], vertices[idx1 * 3 + 2]],
            v2 = [vertices[idx2 * 3], vertices[idx2 * 3 + 1], vertices[idx2 * 3 + 2]],
            v3 = [vertices[idx3 * 3], vertices[idx3 * 3 + 1], vertices[idx3 * 3 + 2]];
        let uv1 = [uvCoords[idx1 * 2], uvCoords[idx1 * 2 + 1]],
            uv2 = [uvCoords[idx2 * 2], uvCoords[idx2 * 2 + 1]],
            uv3 = [uvCoords[idx3 * 2], uvCoords[idx3 * 2 + 1]];
        finalVertices.push(...v1, ...v2, ...v3);
        finalUvCoords.push(...uv1, ...uv2, ...uv3);
    }
    return {
        vertices: new Float32Array(finalVertices),
        uvCoords: new Float32Array(finalUvCoords),
        vertexCount: finalVertices.length / 3,
        isFlatShaded: true
    };
}

async function fetchObjectData(name,url){
try{
let response=await fetch(url),text=await response.text(),
vertexMatch=text.match(/const\s+vertices\s*=\s*new\s+Float32Array\s*\(\s*\[([\s\S]*?)\]\s*\)/s),
uvMatch=text.match(/const\s+uvCoords\s*=\s*new\s+Float32Array\s*\(\s*\[([\s\S]*?)\]\s*\)/s),
indexMatch=text.match(/const\s+indices\s*=\s*new\s+Uint16Array\s*\(\s*\[([\s\S]*?)\]\s*\)/s);
if (!vertexMatch || !uvMatch || !indexMatch) {
    return null;
}
let originalVertices=new Float32Array(vertexMatch[1].split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n))),
    originalUvCoords=new Float32Array(uvMatch[1].split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n))),
    originalIndices=new Uint16Array(indexMatch[1].split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n)));

if(name === 'cube' || name === 'baseplane'){
    models[name] = createFlatShadedData(originalVertices, originalUvCoords, originalIndices);
} else {
    models[name] = {
        vertices: originalVertices,
        uvCoords: originalUvCoords,
        indices: originalIndices,
        isFlatShaded: false
    };
}
models[name].bb = computeBoundingBox(models[name].vertices);
createBuffersForModel(name);
return models[name];
}catch(e){return null;}
}

function resolvePlayerCollisions(pos,vel){
    let iter=0;
    while(iter<5){
        let collisionFound=false;
        let playerAABB = {
            min: [pos[0] - PLAYER_RADIUS, pos[1] - PLAYER_RADIUS, pos[2] - PLAYER_RADIUS],
            max: [pos[0] + PLAYER_RADIUS, pos[1] + PLAYER_RADIUS, pos[2] + PLAYER_RADIUS]
        };

        for(let o of world){
            if(!o.hasCollision||!models[o.name])continue;
            
            let model = models[o.name];
            let M = getObjectMatrix(o.position,o.rotation,o.scale);
            let objectAABB = getObjectAABB(o, M);

            if (!aabbIntersect(playerAABB, objectAABB)) continue;

            let vtx = model.vertices;
            let worldObjectVertices = null;

            if (!model.isFlatShaded) {
                worldObjectVertices = new Float32Array(model.vertices.length);
                for (let k = 0; k < model.vertices.length; k += 3) {
                    let p = transformPoint(M, [model.vertices[k], model.vertices[k+1], model.vertices[k+2]]);
                    worldObjectVertices[k] = p[0];
                    worldObjectVertices[k+1] = p[1];
                    worldObjectVertices[k+2] = p[2];
                }
            }
            
            if (model.isFlatShaded) {
                for(let i=0;i<model.vertexCount;i+=3){
                    let vtxCompIdx1=i*3, vtxCompIdx2=(i+1)*3, vtxCompIdx3=(i+2)*3;
                    let a=transformPoint(M,[vtx[vtxCompIdx1],vtx[vtxCompIdx1+1],vtx[vtxCompIdx1+2]]), 
                        b=transformPoint(M,[vtx[vtxCompIdx2],vtx[vtxCompIdx2+1],vtx[vtxCompIdx2+2]]), 
                        c=transformPoint(M,[vtx[vtxCompIdx3],vtx[vtxCompIdx3+1],vtx[vtxCompIdx3+2]]);
                    let cp=closestPointOnTriangle(pos,a,b,c), diff=[pos[0]-cp[0],pos[1]-cp[1],pos[2]-cp[2]], dist=Math.hypot(diff[0],diff[1],diff[2]);
                    if(dist<PLAYER_RADIUS){
                        collisionFound=true; let pen=PLAYER_RADIUS-dist, n;
                        if(dist>0.0001){n=[diff[0]/dist,diff[1]/dist,diff[2]/dist];} else{let ab_vec=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],ac_vec=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];n=normalize(cross(ab_vec,ac_vec));}
                        pos[0]+=n[0]*pen;pos[1]+=n[1]*pen;pos[2]+=n[2]*pen; if(vel[1]<0&&n[1]>0.7)vel[1]=0;
                        playerAABB = {
                            min: [pos[0] - PLAYER_RADIUS, pos[1] - PLAYER_RADIUS, pos[2] - PLAYER_RADIUS],
                            max: [pos[0] + PLAYER_RADIUS, pos[1] + PLAYER_RADIUS, pos[2] + PLAYER_RADIUS]
                        };
                    }
                }
            } else {
                let indices = model.indices;
                for(let i=0;i<indices.length;i+=3){
                    let idx1 = indices[i]*3, idx2 = indices[i+1]*3, idx3 = indices[i+2]*3;
                    let a=[worldObjectVertices[idx1], worldObjectVertices[idx1+1], worldObjectVertices[idx1+2]], 
                        b=[worldObjectVertices[idx2], worldObjectVertices[idx2+1], worldObjectVertices[idx2+2]], 
                        c=[worldObjectVertices[idx3], worldObjectVertices[idx3+1], worldObjectVertices[idx3+2]];
                    let cp=closestPointOnTriangle(pos,a,b,c), diff=[pos[0]-cp[0],pos[1]-cp[1],pos[2]-cp[2]], dist=Math.hypot(diff[0],diff[1],diff[2]);
                    if(dist<PLAYER_RADIUS){
                        collisionFound=true; let pen=PLAYER_RADIUS-dist, n;
                        if(dist>0.0001){n=[diff[0]/dist,diff[1]/dist,diff[2]/dist];} else{let ab_vec=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],ac_vec=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];n=normalize(cross(ab_vec,ac_vec));}
                        pos[0]+=n[0]*pen;pos[1]+=n[1]*pen;pos[2]+=n[2]*pen; if(vel[1]<0&&n[1]>0.7)vel[1]=0;
                        playerAABB = {
                            min: [pos[0] - PLAYER_RADIUS, pos[1] - PLAYER_RADIUS, pos[2] - PLAYER_RADIUS],
                            max: [pos[0] + PLAYER_RADIUS, pos[1] + PLAYER_RADIUS, pos[2] + PLAYER_RADIUS]
                        };
                    }
                }
            }
        }
        if(!collisionFound)break; 
        iter++;
    }
    return {position:pos,velocity:vel};
}

function isOnGround(pos){
    if(!gravityEnabled||!collisionsEnabled)return false;
    let checkRadius = PLAYER_RADIUS + GROUND_EPSILON; 
    let playerAABB = {
        min: [pos[0] - PLAYER_RADIUS, pos[1] - checkRadius, pos[2] - PLAYER_RADIUS],
        max: [pos[0] + PLAYER_RADIUS, pos[1] + PLAYER_RADIUS, pos[2] + PLAYER_RADIUS] 
    };

    for(let o of world){
        if(!o.hasCollision||!models[o.name])continue;
        
        let model = models[o.name];
        let M = getObjectMatrix(o.position,o.rotation,o.scale);
        let objectAABB = getObjectAABB(o, M);

        if (!aabbIntersect(playerAABB, objectAABB)) continue;
        
        let vtx=model.vertices;
        let worldObjectVertices = null;

        if (!model.isFlatShaded) {
            worldObjectVertices = new Float32Array(model.vertices.length);
            for (let k = 0; k < model.vertices.length; k += 3) {
                let p = transformPoint(M, [model.vertices[k], model.vertices[k+1], model.vertices[k+2]]);
                worldObjectVertices[k] = p[0];
                worldObjectVertices[k+1] = p[1];
                worldObjectVertices[k+2] = p[2];
            }
        }

        if (model.isFlatShaded) {
            for(let i=0;i<model.vertexCount;i+=3){
                let vtxCompIdx1=i*3, vtxCompIdx2=(i+1)*3, vtxCompIdx3=(i+2)*3;
                let a=transformPoint(M,[vtx[vtxCompIdx1],vtx[vtxCompIdx1+1],vtx[vtxCompIdx1+2]]), 
                    b=transformPoint(M,[vtx[vtxCompIdx2],vtx[vtxCompIdx2+1],vtx[vtxCompIdx2+2]]), 
                    c=transformPoint(M,[vtx[vtxCompIdx3],vtx[vtxCompIdx3+1],vtx[vtxCompIdx3+2]]);
                let cp=closestPointOnTriangle(pos,a,b,c), diff=[pos[0]-cp[0],pos[1]-cp[1],pos[2]-cp[2]], dist=Math.hypot(diff[0],diff[1],diff[2]);
                if(dist<PLAYER_RADIUS+0.01){ 
                    let ab_vec=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],ac_vec=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];
                    let n=normalize(cross(ab_vec,ac_vec)); 
                    if(dot(n, diff) < 0) { n = [-n[0], -n[1], -n[2]]; }
                    if(n[1]>0.7 && Math.abs(pos[1]-PLAYER_RADIUS-cp[1])<GROUND_EPSILON) return true; 
                }
            }
        } else {
            let indices = model.indices;
            for(let i=0;i<indices.length;i+=3){
                let idx1 = indices[i]*3, idx2 = indices[i+1]*3, idx3 = indices[i+2]*3;
                let a=[worldObjectVertices[idx1], worldObjectVertices[idx1+1], worldObjectVertices[idx1+2]], 
                    b=[worldObjectVertices[idx2], worldObjectVertices[idx2+1], worldObjectVertices[idx2+2]], 
                    c=[worldObjectVertices[idx3], worldObjectVertices[idx3+1], worldObjectVertices[idx3+2]];
                let cp=closestPointOnTriangle(pos,a,b,c), diff=[pos[0]-cp[0],pos[1]-cp[1],pos[2]-cp[2]], dist=Math.hypot(diff[0],diff[1],diff[2]);
                if(dist<PLAYER_RADIUS+0.01){ 
                    let ab_vec=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],ac_vec=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];
                    let n=normalize(cross(ab_vec,ac_vec));
                    if(dot(n, diff) < 0) { n = [-n[0], -n[1], -n[2]]; }
                    if(n[1]>0.7 && Math.abs(pos[1]-PLAYER_RADIUS-cp[1])<GROUND_EPSILON) return true; 
                }
            }
        }
    }
    return false;
}

function createBuffersForModel(modelName){
let model=models[modelName];
buffers[modelName]={ vertex:gl.createBuffer(), uv:gl.createBuffer() };
gl.bindBuffer(gl.ARRAY_BUFFER,buffers[modelName].vertex); gl.bufferData(gl.ARRAY_BUFFER,model.vertices,gl.STATIC_DRAW);
gl.bindBuffer(gl.ARRAY_BUFFER,buffers[modelName].uv); gl.bufferData(gl.ARRAY_BUFFER,model.uvCoords,gl.STATIC_DRAW);
if (!model.isFlatShaded) {
buffers[modelName].index = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers[modelName].index); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, model.indices, gl.STATIC_DRAW);
}
}
function createShader(type,source){
let shader=gl.createShader(type); gl.shaderSource(shader,source); gl.compileShader(shader);
if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){ gl.deleteShader(shader); return null; }
return shader;
}
function createProgram(vertShader,fragShader){
let program=gl.createProgram(); gl.attachShader(program,vertShader); gl.attachShader(program,fragShader); gl.linkProgram(program);
if(!gl.getProgramParameter(program,gl.LINK_STATUS)){ gl.deleteProgram(program); return null; }
return program;
}
function initWireProgram(){ let vShader=createShader(gl.VERTEX_SHADER,wireVertexShaderSource),fShader=createShader(gl.FRAGMENT_SHADER,wireFragmentShaderSource); return createProgram(vShader,fShader); }

function initHitboxBuffer(){
let vertices=new Float32Array([-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1]);
hitboxBuffer=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,hitboxBuffer); gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
let indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);
hitboxIndexBuffer=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,hitboxIndexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW);
}
function initPlayerCollisionBuffer(){
let segments=32,vertices=[];
for(let i=0;i<segments;i++){ let theta=i/segments*2*Math.PI; vertices.push(PLAYER_RADIUS*Math.cos(theta),0,PLAYER_RADIUS*Math.sin(theta)); }
vertices.push(PLAYER_RADIUS*Math.cos(0),0,PLAYER_RADIUS*Math.sin(0));

for(let i=0; i < segments; i+= Math.max(1, segments/8) ){
    let theta=i/segments*2*Math.PI;
    let x = PLAYER_RADIUS*Math.cos(theta);
    let z = PLAYER_RADIUS*Math.sin(theta);
    vertices.push(x, -PLAYER_CAPSULE_HEIGHT/2, z, x, PLAYER_CAPSULE_HEIGHT/2, z);
}
for(let j = -1; j <= 1; j+=2) {
    let y_offset = j * PLAYER_CAPSULE_HEIGHT / 2;
    for(let i=0;i<segments;i++){ let theta=i/segments*2*Math.PI; vertices.push(PLAYER_RADIUS*Math.cos(theta),y_offset,PLAYER_RADIUS*Math.sin(theta)); }
    vertices.push(PLAYER_RADIUS*Math.cos(0),y_offset,PLAYER_RADIUS*Math.sin(0));
}

let buffer=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buffer); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
return {buffer:buffer,segments:segments,vertexCount:vertices.length/3};
}
function getProjectionMatrix(){ let fov=Math.PI/4,aspect=canvas.width/canvas.height,near=0.1,far=1000.0,f=1.0/Math.tan(fov/2),nf=1/(near-far); return new Float32Array([f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,2*far*near*nf,0]); }
function lookAt(eye,center,up){
let f=normalize([center[0]-eye[0],center[1]-eye[1],center[2]-eye[2]]);
let s=normalize(cross(f,up));
let u=cross(s,f);
return new Float32Array([s[0],u[0],-f[0],0, s[1],u[1],-f[1],0, s[2],u[2],-f[2],0, -dot(s,eye),-dot(u,eye),dot(f,eye),1]);
}
function getModelViewMatrix(){
let eye=playerPosition,pitch=playerRotation[0],yaw=playerRotation[1], cp=Math.cos(pitch),sp=Math.sin(pitch),cy=Math.cos(yaw),sy=Math.sin(yaw);
let forward=[cp*sy,sp,cp*cy],center=[eye[0]+forward[0],eye[1]+forward[1],eye[2]+forward[2]],up=[0,1,0];
return lookAt(eye,center,up);
}
function getObjectMatrix(pos,rot,scale){
let [x,y,z]=pos,[rx,ry,rz]=rot,[sx,sy,sz]=scale, cx=Math.cos(rx),sxr=Math.sin(rx),cy=Math.cos(ry),syr=Math.sin(ry), cz=Math.cos(rz),szr=Math.sin(rz);
let m00=cy*cz,m01=-cy*szr,m02=syr, m10=cx*szr+cz*sxr*syr,m11=cx*cz-sxr*syr*szr,m12=-cy*sxr, m20=sxr*szr-cx*cz*syr,m21=cz*sxr+cx*syr*szr,m22=cx*cy;
return new Float32Array([m00*sx,m10*sx,m20*sx,0, m01*sy,m11*sy,m21*sy,0, m02*sz,m12*sz,m22*sz,0, x,y,z,1]);
}
function multiplyMatrices(a,b){
let out=new Float32Array(16);
for(let i=0;i<4;i++){ for(let j=0;j<4;j++){ out[i+j*4]=a[i]*b[j*4]+a[i+4]*b[j*4+1]+a[i+8]*b[j*4+2]+a[i+12]*b[j*4+3]; } }
return out;
}
function getAABBHitboxMatrix(obj, objectMatrix){
let aabb=getObjectAABB(obj, objectMatrix), center=[(aabb.min[0]+aabb.max[0])/2,(aabb.min[1]+aabb.max[1])/2,(aabb.min[2]+aabb.max[2])/2];
let sX=(aabb.max[0]-aabb.min[0])/2,sY=(aabb.max[1]-aabb.min[1])/2,sZ=(aabb.max[2]-aabb.min[2])/2;
return new Float32Array([sX,0,0,0,0,sY,0,0,0,0,sZ,0,center[0],center[1],center[2],1]);
}

function getObjectAABB(obj, precomputedMatrix = null){
if(!models[obj.name]||!models[obj.name].bb)return {min:[obj.position[0],obj.position[1],obj.position[2]],max:[obj.position[0],obj.position[1],obj.position[2]]};
let bb=models[obj.name].bb,xs=[bb.minX,bb.minX+bb.width],ys=[bb.minY,bb.minY+bb.height],zs=[bb.minZ,bb.minZ+bb.depth];
let m = precomputedMatrix ? precomputedMatrix : getObjectMatrix(obj.position,obj.rotation,obj.scale);
let corners=[];
for(let ix=0;ix<2;ix++){ for(let iy=0;iy<2;iy++){ for(let iz=0;iz<2;iz++){ let p=[xs[ix],ys[iy],zs[iz]],t=transformPoint(m,p); corners.push(t); } } }
let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
for(let c of corners){
if(c[0]<minX)minX=c[0]; if(c[1]<minY)minY=c[1]; if(c[2]<minZ)minZ=c[2];
if(c[0]>maxX)maxX=c[0]; if(c[1]>maxY)maxY=c[1]; if(c[2]>maxZ)maxZ=c[2];
}
if(maxY-minY<0.001){minY-=0.05;maxY+=0.05;} return {min:[minX,minY,minZ],max:[maxX,maxY,maxZ]};
}
function aabbIntersect(a,b){ return a.min[0]<=b.max[0]&&a.max[0]>=b.min[0]&&a.min[1]<=b.max[1]&&a.max[1]>=b.min[1]&&a.min[2]<=b.max[2]&&a.max[2]>=b.min[2]; }
function updateDebugInfo(){
if(developerMode){
debugOverlay.innerHTML=`FPS: ${fps}<br>Pos:(${playerPosition[0].toFixed(2)}, ${playerPosition[1].toFixed(2)}, ${playerPosition[2].toFixed(2)})<br>Vel:(${playerVelocity[0].toFixed(2)}, ${playerVelocity[1].toFixed(2)}, ${playerVelocity[2].toFixed(2)})<br>Rot:(${(playerRotation[0]*180/Math.PI).toFixed(2)}, ${(playerRotation[1]*180/Math.PI).toFixed(2)}, ${(playerRotation[2]*180/Math.PI).toFixed(2)})°<br>Gravity: ${gravityEnabled?"On":"Off"}<br>Collisions: ${collisionsEnabled?"On":"Off"}<br>Hitboxes: ${showHitboxes?"On":"Off"}<br>Grounded: ${isOnGround(playerPosition)?"Yes":"No"}<br>Models: ${Object.keys(models).join(", ")}`;
debugOverlay.style.display="block";
} else {debugOverlay.style.display="none";}
}

function updatePhysics(dt){
    let dx = 0;
    let dz = 0;
    const yaw = playerRotation[1];
    const sinYaw = Math.sin(yaw);
    const cosYaw = Math.cos(yaw);

    if (moveInput.forward !== 0 || moveInput.strafe !== 0) {
        dx += moveInput.forward * sinYaw * MOVE_SPEED;
        dz += moveInput.forward * cosYaw * MOVE_SPEED;
        dx -= moveInput.strafe * cosYaw * MOVE_SPEED;
        dz += moveInput.strafe * sinYaw * MOVE_SPEED;
    }
    
    playerVelocity[0] = dx;
    playerVelocity[2] = dz;
    
    let grounded = isOnGround(playerPosition);

    if(gravityEnabled){
        if(!grounded){ 
            playerVelocity[1]+=GRAVITY*dt; 
            if(playerVelocity[1]<MAX_FALL_SPEED)playerVelocity[1]=MAX_FALL_SPEED; 
        } else if(playerVelocity[1] < 0) { 
            playerVelocity[1]=0;
        }
    } else {
        playerVelocity[1] = moveInput.vertical * FLY_SPEED;
    }
    
    playerRotation[1] += lookInput.yaw * LOOK_SENSITIVITY;
    playerRotation[0] += lookInput.pitch * LOOK_SENSITIVITY;
    playerRotation[0] = Math.max(-Math.PI / 2 + 0.001, Math.min(Math.PI / 2 - 0.001, playerRotation[0]));
    lookInput.yaw = 0;
    lookInput.pitch = 0;

    let intendedPos=[playerPosition[0]+playerVelocity[0]*dt,playerPosition[1]+playerVelocity[1]*dt,playerPosition[2]+playerVelocity[2]*dt];
    let tempVelocity = [playerVelocity[0], playerVelocity[1], playerVelocity[2]]; 

    let resolved=collisionsEnabled?resolvePlayerCollisions([...intendedPos],tempVelocity):{position:intendedPos,velocity:tempVelocity};
    playerPosition=resolved.position;
    playerVelocity=resolved.velocity; 

    for(let o of world){
        if(o.hasGravity){
            if(!o.velocity)o.velocity=[0,0,0];
            o.velocity[1]+=GRAVITY*dt; 
            if(o.velocity[1]<MAX_FALL_SPEED)o.velocity[1]=MAX_FALL_SPEED;
            let intendedO=[o.position[0],o.position[1]+o.velocity[1]*dt,o.position[2]];
            o.position=resolveObjectCollisions(o,intendedO);
        }
    }
}

function resolveObjectCollisions(obj,pos){
    let iter=0,colliding=true;
    while(colliding&&iter<5){
        colliding=false; 
        let aabb = getObjectAABB({ ...obj, position: pos });
        for(let other of world){
            if(other===obj||!other.hasCollision)continue;
            let otherMatrix = getObjectMatrix(other.position, other.rotation, other.scale);
            let oAABB=getObjectAABB(other, otherMatrix);
            if(aabbIntersect(aabb,oAABB)){
                colliding=true;
                let ca=[(aabb.min[0]+aabb.max[0])/2,(aabb.min[1]+aabb.max[1])/2,(aabb.min[2]+aabb.max[2])/2], cb=[(oAABB.min[0]+oAABB.max[0])/2,(oAABB.min[1]+oAABB.max[1])/2,(oAABB.min[2]+oAABB.max[2])/2];
                let ox=Math.min(aabb.max[0],oAABB.max[0])-Math.max(aabb.min[0],oAABB.min[0]), oy=Math.min(aabb.max[1],oAABB.max[1])-Math.max(aabb.min[1],oAABB.min[1]), oz=Math.min(aabb.max[2],oAABB.max[2])-Math.max(aabb.min[2],oAABB.min[2]);
                if(ox<oy&&ox<oz){let s=ca[0]<cb[0]?-1:1;pos[0]+=ox*s;}
                else if(oy<ox&&oy<oz){let s=ca[1]<cb[1]?-1:1;pos[1]+=oy*s; if(obj.velocity && obj.velocity[1] < 0 && s > 0) obj.velocity[1] = 0;}
                else{let s=ca[2]<cb[2]?-1:1;pos[2]+=oz*s;}
                aabb=getObjectAABB({...obj,position:pos}); 
                break; 
            }
        }
        iter++;
    }
    return pos;
}
function getPlayerCollisionMatrix(){ 
    const playerVisualHeightOffset = -PLAYER_CAPSULE_HEIGHT / 2 + PLAYER_RADIUS;
    return new Float32Array([PLAYER_RADIUS,0,0,0, 0,PLAYER_CAPSULE_HEIGHT/2,0,0, 0,0,PLAYER_RADIUS,0, playerPosition[0],playerPosition[1] + playerVisualHeightOffset,playerPosition[2],1]); 
}

let glRes = {};
async function initGL(){
let vertexShader=createShader(gl.VERTEX_SHADER,vertexShaderSource), fragmentShader=createShader(gl.FRAGMENT_SHADER,fragmentShaderSource);
glRes.program=createProgram(vertexShader,fragmentShader);
gl.useProgram(glRes.program);
await Promise.all([
fetchObjectData("cube","./assets/models/cube.txt"),
fetchObjectData("tank","./assets/models/tanko.txt"),
fetchObjectData("dummy","./assets/models/dummy.txt"),
fetchObjectData("baseplane","./assets/models/baseplane.txt")
]);
return glRes;
}
function initWire(){ wireProgram=initWireProgram(); initHitboxBuffer(); }
function drawWireframeCollisions(prog,mvMat,proj){
gl.useProgram(prog);
let posLoc=gl.getAttribLocation(prog,"position"),projLoc=gl.getUniformLocation(prog,"projectionMatrix"),mvLoc=gl.getUniformLocation(prog,"modelViewMatrix"),colorLoc=gl.getUniformLocation(prog,"color");
gl.uniformMatrix4fv(projLoc,false,proj);
gl.bindBuffer(gl.ARRAY_BUFFER,hitboxBuffer); gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(posLoc);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,hitboxIndexBuffer); gl.uniform4f(colorLoc,1,0,0,1);
world.forEach(o=>{
if(!o.hasCollision || !models[o.name])return;
let objMatrix = getObjectMatrix(o.position, o.rotation, o.scale);
let hitMat=getAABBHitboxMatrix(o, objMatrix);
let combined=multiplyMatrices(mvMat,hitMat);
gl.uniformMatrix4fv(mvLoc,false,combined); gl.drawElements(gl.LINES,24,gl.UNSIGNED_SHORT,0);
});

if (playerCollisionBuffer && playerCollisionBuffer.buffer) {
    gl.uniform4f(colorLoc,0,1,0,1);
    gl.bindBuffer(gl.ARRAY_BUFFER,playerCollisionBuffer.buffer); 
    gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0); 
    gl.enableVertexAttribArray(posLoc);
    let playerMat=getPlayerCollisionMatrix(); 
    gl.uniformMatrix4fv(mvLoc,false,multiplyMatrices(mvMat,playerMat));
    gl.drawArrays(gl.LINES,0,playerCollisionBuffer.vertexCount);
}
}
function loadAllTexturesForObject(obj) {
if (obj.texture && typeof obj.texture === 'string') obj.texture = loadTexture(obj.texture);
}

async function init(){
glRes = await initGL(); initWire(); playerCollisionBuffer=initPlayerCollisionBuffer();
world.forEach(loadAllTexturesForObject);
function draw(){
let now=performance.now(),dt=Math.min((now-lastDrawTime)/1000,0.05);
fps=Math.round(1000/(now-lastDrawTime)); lastDrawTime=now; updatePhysics(dt);

gl.viewport(0,0,canvas.width,canvas.height);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.cullFace(gl.BACK);
let posLoc=0, texLoc=1;
let proj=getProjectionMatrix(),mvMat=getModelViewMatrix();
gl.useProgram(glRes.program);
gl.uniformMatrix4fv(gl.getUniformLocation(glRes.program,"projectionMatrix"),false,proj);
gl.uniformMatrix4fv(gl.getUniformLocation(glRes.program,"modelViewMatrix"),false,mvMat);

world.forEach(o=>{
if(!models[o.name]||!buffers[o.name] || !o.texture)return;
let model = models[o.name]; let buffer = buffers[o.name];
gl.bindBuffer(gl.ARRAY_BUFFER,buffer.vertex); gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(posLoc);
gl.bindBuffer(gl.ARRAY_BUFFER,buffer.uv); gl.vertexAttribPointer(texLoc,2,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(texLoc);

gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,o.texture); gl.uniform1i(gl.getUniformLocation(gl.program,"uTexture"),0);

let objMat=getObjectMatrix(o.position,o.rotation,o.scale);
gl.uniformMatrix4fv(gl.getUniformLocation(glRes.program,"objectMatrix"),false,objMat);

if(model.isFlatShaded){
gl.disable(gl.CULL_FACE);
gl.drawArrays(gl.TRIANGLES, 0, model.vertexCount);
gl.enable(gl.CULL_FACE);
} else {
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.index);
gl.drawElements(gl.TRIANGLES, model.indices.length, gl.UNSIGNED_SHORT, 0);
}
});
gl.disableVertexAttribArray(posLoc);
gl.disableVertexAttribArray(texLoc);


if(showHitboxes && wireProgram){ drawWireframeCollisions(wireProgram,mvMat,proj); gl.useProgram(glRes.program); }
updateDebugInfo(); requestAnimationFrame(draw);
}
draw();
}
function loadTexture(url){
let texture=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,texture); let pixel=new Uint8Array([128,128,128,255]);
gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,pixel);
let image=new Image(); image.crossOrigin="anonymous";
image.onload=()=>{
gl.bindTexture(gl.TEXTURE_2D,texture); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);
if ( (image.width & (image.width - 1)) === 0 && (image.height & (image.height - 1)) === 0 ) {
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
} else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
}
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
};
image.onerror=()=>{ const errorPixel = new Uint8Array([255, 0, 255, 255]); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, errorPixel); }
image.src=url; return texture;
}
function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }

function handleAlexaMessage(message) {
    if (!message) return;
    switch(message.type) {
        case 'MOVE':
            moveInput.forward = message.direction === 'forward' ? 1 : (message.direction === 'backward' ? -1 : 0);
            moveInput.strafe = message.direction === 'left' ? 1 : (message.direction === 'right' ? -1 : 0);
            moveInput.vertical = message.direction === 'up' ? 1 : (message.direction === 'down' ? -1 : 0);
            break;
        case 'STOP':
            moveInput = { forward: 0, strafe: 0, vertical: 0 };
            break;
        case 'LOOK':
            lookInput.yaw = message.direction === 'left' ? -1 : (message.direction === 'right' ? 1 : 0);
            lookInput.pitch = message.direction === 'up' ? 1 : (message.direction === 'down' ? -1 : 0);
            break;
        case 'JUMP':
            if (gravityEnabled && isOnGround(playerPosition)) {
                playerVelocity[1] = JUMP_FORCE;
            }
            break;
        case 'TOGGLE_GRAVITY':
            gravityEnabled = !gravityEnabled;
            if(!gravityEnabled) playerVelocity[1] = 0;
            break;
        case 'TOGGLE_COLLISIONS':
            collisionsEnabled = !collisionsEnabled;
            break;
        case 'TOGGLE_HITBOXES':
            showHitboxes = !showHitboxes;
            break;
        case 'TOGGLE_DEV_MODE':
            developerMode = !developerMode;
            break;
    }
}

Alexa.create({
    onReady: () => {
        alexa = window.alexa;
        alexa.message.register(handleAlexaMessage);
        init();
    }
});

window.addEventListener("resize",resizeCanvas);
document.addEventListener("visibilitychange",()=>{if(!document.hidden)lastDrawTime=performance.now();});

resizeCanvas();
</script>
</body>
</html>